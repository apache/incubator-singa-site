<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Singa: singa Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Singa
   </div>
   <div id="projectbrief">A General Distributed Deep Learning Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">singa Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinga_1_1__Context.html">_Context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Accuracy.html">Accuracy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the accuray of the prediction, which is matched against the ground truth labels.  <a href="classsinga_1_1Accuracy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1AdaGrad.html">AdaGrad</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsinga_1_1Block.html" title="Block represent a chunk of memory (on device or host). ">Block</a> represent a chunk of memory (on device or host).  <a href="classsinga_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Channel.html">Channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsinga_1_1Channel.html" title="Channel for appending metrics or other information into files or screen. ">Channel</a> for appending metrics or other information into files or screen.  <a href="classsinga_1_1Channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1ChannelManager.html">ChannelManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply constraints for parameters (gradient).  <a href="classsinga_1_1Constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1CppCPU.html">CppCPU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a CPU device which may have multiple threads/executors.  <a href="classsinga_1_1CppCPU.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1CSVDecoder.html">CSVDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the string of csv formated data into data tensor (dtype is kFloat32) and optionally a label tensor (dtype is kInt).  <a href="classsinga_1_1CSVDecoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1CSVEncoder.html">CSVEncoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert values from tensors into a csv formated string.  <a href="classsinga_1_1CSVEncoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Decoder.html">Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base decoder that converts a string into a set of tensors.  <a href="classsinga_1_1Decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Device.html">Device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory and execute <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> operations.  <a href="classsinga_1_1Device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1DeviceMemPool.html">DeviceMemPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Encoder.html">Encoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base encoder class that convert a set of tensors into string for storage.  <a href="classsinga_1_1Encoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1FeedForwardNet.html">FeedForwardNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The feed-forward neural net.  <a href="classsinga_1_1FeedForwardNet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1ImageTransformer.html">ImageTransformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Initializer.html">Initializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Layer.html">Layer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base layer class.  <a href="classsinga_1_1Layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1LocalUpdater.html">LocalUpdater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsinga_1_1LocalUpdater.html" title="LocalUpdater do gradient aggregation and update gradient calling the wrapped Optimizer on a specific ...">LocalUpdater</a> do gradient aggregation and update gradient calling the wrapped <a class="el" href="classsinga_1_1Optimizer.html" title="The base class for gradient descent algorithms used to update the model parameters in order to optimi...">Optimizer</a> on a specific device (i.e., CPU or GPU).  <a href="classsinga_1_1LocalUpdater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Loss.html">Loss</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base loss class, which declares the APIs for computing the objective score (loss) for a pair of prediction (from the model) and the target (i.e.  <a href="classsinga_1_1Loss.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Metric.html">Metric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base metric class, which declares the APIs for computing the performance evaluation metrics given the prediction of the model and the ground truth, i.e., the target.  <a href="classsinga_1_1Metric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1MSE.html">MSE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsinga_1_1MSE.html" title="MSE is for mean squared error or squared euclidean distance. ">MSE</a> is for mean squared error or squared euclidean distance.  <a href="classsinga_1_1MSE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Nesterov.html">Nesterov</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Optimizer.html">Optimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for gradient descent algorithms used to update the model parameters in order to optimize the objective (loss) function.  <a href="classsinga_1_1Optimizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Platform.html">Platform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class queries all available calculating devices on a given machine grouped according to manufacturer or device drivers.  <a href="classsinga_1_1Platform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Regularizer.html">Regularizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply regularization for parameters (gradient), e.g., L1 norm and L2 norm.  <a href="classsinga_1_1Regularizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1RMSProp.html">RMSProp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Scheduler.html">Scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> operations with dependency detection.  <a href="classsinga_1_1Scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1SGD.html">SGD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Snapshot.html">Snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The snapshot management.  <a href="classsinga_1_1Snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1SoftmaxCrossEntropy.html">SoftmaxCrossEntropy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Softmax + cross entropy for multi-category classification.  <a href="classsinga_1_1SoftmaxCrossEntropy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> instance is a multi-dimensional array resident on a <a class="el" href="classsinga_1_1Device.html" title="Allocate memory and execute Tensor operations. ">Device</a> (default device is the host CPU).  <a href="classsinga_1_1Tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For benchmarking the time cost of operations.  <a href="classsinga_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Tokenizer.html">Tokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenize a string.  <a href="classsinga_1_1Tokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Transformer.html">Transformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base apply class that does data transformations in pre-processing stage.  <a href="classsinga_1_1Transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1Updater.html">Updater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classsinga_1_1Updater.html" title="Basic Updater class just forward all the method function call to the wrapped Optimizer. ">Updater</a> class just forward all the method function call to the wrapped <a class="el" href="classsinga_1_1Optimizer.html" title="The base class for gradient descent algorithms used to update the model parameters in order to optimi...">Optimizer</a>.  <a href="classsinga_1_1Updater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinga_1_1VirtualMemory.html">VirtualMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage device memory pool including garbage collection, memory opt.  <a href="classsinga_1_1VirtualMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a20e84147cbee28237f2274fd6d680e41"><td class="memItemLeft" align="right" valign="top"><a id="a20e84147cbee28237f2274fd6d680e41"></a>
typedef struct <a class="el" href="structsinga_1_1__Context.html">singa::_Context</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b></td></tr>
<tr class="separator:a20e84147cbee28237f2274fd6d680e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e619b28136532aeacbccc5a0056088"><td class="memItemLeft" align="right" valign="top"><a id="ad4e619b28136532aeacbccc5a0056088"></a>
typedef vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Shape</b></td></tr>
<tr class="separator:ad4e619b28136532aeacbccc5a0056088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e303fc44cfdbf2611a6e69affa42e9"><td class="memItemLeft" align="right" valign="top"><a id="ac7e303fc44cfdbf2611a6e69affa42e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ac7e303fc44cfdbf2611a6e69affa42e9">InitializerConf</a> = FillerConf</td></tr>
<tr class="memdesc:ac7e303fc44cfdbf2611a6e69affa42e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for initializing parameter values. <br /></td></tr>
<tr class="separator:ac7e303fc44cfdbf2611a6e69affa42e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1c39cb26143562db85f282ee7037e873"><td class="memItemLeft" align="right" valign="top"><a id="a1c39cb26143562db85f282ee7037e873"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>SizeOf</b> (DataType t)</td></tr>
<tr class="separator:a1c39cb26143562db85f282ee7037e873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1624bfa67fd3fd8b03783b5cdb2e9e0a"><td class="memItemLeft" align="right" valign="top"><a id="a1624bfa67fd3fd8b03783b5cdb2e9e0a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>Product</b> (const Shape &amp;shape, int start=0, size_t len=0)</td></tr>
<tr class="separator:a1624bfa67fd3fd8b03783b5cdb2e9e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e991c4d444522f9f1b1b59d53bc0fa"><td class="memItemLeft" align="right" valign="top"><a id="aa1e991c4d444522f9f1b1b59d53bc0fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckDataTypeAndLang</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in1, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in2)</td></tr>
<tr class="separator:aa1e991c4d444522f9f1b1b59d53bc0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4422d33510caa67f6baef197aee05e1a"><td class="memTemplParams" colspan="2"><a id="a4422d33510caa67f6baef197aee05e1a"></a>
template&lt;typename FromType , typename ToType &gt; </td></tr>
<tr class="memitem:a4422d33510caa67f6baef197aee05e1a"><td class="memTemplItemLeft" align="right" valign="top">ToType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TypeCast</b> (const FromType &amp;x)</td></tr>
<tr class="separator:a4422d33510caa67f6baef197aee05e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9ca55a5163c63c32018c3f8d237b16"><td class="memItemLeft" align="right" valign="top"><a id="a1d9ca55a5163c63c32018c3f8d237b16"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Boradcast</b> (const Shape &amp;shape)</td></tr>
<tr class="separator:a1d9ca55a5163c63c32018c3f8d237b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4845cf0243e227bdf92a7cb536698ec9"><td class="memItemLeft" align="right" valign="top"><a id="a4845cf0243e227bdf92a7cb536698ec9"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a4845cf0243e227bdf92a7cb536698ec9">Reshape</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const Shape &amp;s)</td></tr>
<tr class="memdesc:a4845cf0243e227bdf92a7cb536698ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape the given tensor and generate a new tensor; the total vol should match which shares the memory with in if possible. <br /></td></tr>
<tr class="separator:a4845cf0243e227bdf92a7cb536698ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66b52448cee240fc36c418740186037"><td class="memItemLeft" align="right" valign="top"><a id="aa66b52448cee240fc36c418740186037"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Resize</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const Shape &amp;s)</td></tr>
<tr class="separator:aa66b52448cee240fc36c418740186037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b658f8813175483db55a31e0e02d15c"><td class="memItemLeft" align="right" valign="top"><a id="a2b658f8813175483db55a31e0e02d15c"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a2b658f8813175483db55a31e0e02d15c">Transpose</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="memdesc:a2b658f8813175483db55a31e0e02d15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the shape vector. <br /></td></tr>
<tr class="separator:a2b658f8813175483db55a31e0e02d15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9538934cbeb21fbad68cae5bc656e94"><td class="memItemLeft" align="right" valign="top"><a id="ae9538934cbeb21fbad68cae5bc656e94"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ae9538934cbeb21fbad68cae5bc656e94">Broadcast</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const Shape &amp;shape)</td></tr>
<tr class="memdesc:ae9538934cbeb21fbad68cae5bc656e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a view of the input tensor whose shape is broadcasted to be compitable with the given shape. <br /></td></tr>
<tr class="separator:ae9538934cbeb21fbad68cae5bc656e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3785f288bc3b577696b8283129162b"><td class="memItemLeft" align="right" valign="top"><a id="abc3785f288bc3b577696b8283129162b"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#abc3785f288bc3b577696b8283129162b">Transpose</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const vector&lt; size_t &gt; &amp;axes)</td></tr>
<tr class="memdesc:abc3785f288bc3b577696b8283129162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the axes. <br /></td></tr>
<tr class="separator:abc3785f288bc3b577696b8283129162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c886196156af2804db614775d2d29f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a62c886196156af2804db614775d2d29f">CopyDataToFrom</a> (<a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *dst, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;src, const size_t num, const size_t dst_offset=0, const size_t src_offset=0)</td></tr>
<tr class="memdesc:a62c886196156af2804db614775d2d29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy 'num' elements of src to dst.  <a href="#a62c886196156af2804db614775d2d29f">More...</a><br /></td></tr>
<tr class="separator:a62c886196156af2804db614775d2d29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe4b7ab7ebc2f94147d56f2748d25e7"><td class="memItemLeft" align="right" valign="top"><a id="aafe4b7ab7ebc2f94147d56f2748d25e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RepeatDataToFrom</b> (bool broadcast_flag, const vector&lt; size_t &gt; &amp;repeats, int axis, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *dst, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const size_t num)</td></tr>
<tr class="separator:aafe4b7ab7ebc2f94147d56f2748d25e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace7e952608242932fbb9293b73fe366"><td class="memItemLeft" align="right" valign="top"><a id="aace7e952608242932fbb9293b73fe366"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Abs</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:aace7e952608242932fbb9293b73fe366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7aa8356a4a49f762b89d5c5a53136f6"><td class="memItemLeft" align="right" valign="top"><a id="af7aa8356a4a49f762b89d5c5a53136f6"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Exp</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:af7aa8356a4a49f762b89d5c5a53136f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac701cb35a4e0cfa683d5dee5c50496"><td class="memItemLeft" align="right" valign="top"><a id="aeac701cb35a4e0cfa683d5dee5c50496"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Log</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:aeac701cb35a4e0cfa683d5dee5c50496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f21abd47424f057389ea0885b73d82"><td class="memItemLeft" align="right" valign="top"><a id="a12f21abd47424f057389ea0885b73d82"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReLU</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:a12f21abd47424f057389ea0885b73d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745e5e4ececf258aad431fc001dac77f"><td class="memItemLeft" align="right" valign="top"><a id="a745e5e4ececf258aad431fc001dac77f"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Sigmoid</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:a745e5e4ececf258aad431fc001dac77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782f9a85c013e5540d3139ba51c8ea21"><td class="memItemLeft" align="right" valign="top"><a id="a782f9a85c013e5540d3139ba51c8ea21"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Sign</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:a782f9a85c013e5540d3139ba51c8ea21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3c5f1149a4c08a9be24935b517ca23"><td class="memItemLeft" align="right" valign="top"><a id="adb3c5f1149a4c08a9be24935b517ca23"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Sqrt</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:adb3c5f1149a4c08a9be24935b517ca23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a17d8129bf3562f00d37bea9eb48a10"><td class="memItemLeft" align="right" valign="top"><a id="a8a17d8129bf3562f00d37bea9eb48a10"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Square</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:a8a17d8129bf3562f00d37bea9eb48a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042ff88cdeadcc04b2abda23c6c66ec8"><td class="memItemLeft" align="right" valign="top"><a id="a042ff88cdeadcc04b2abda23c6c66ec8"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Tanh</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:a042ff88cdeadcc04b2abda23c6c66ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b79e9d3ed6ab7cb7b2d18c9187f323"><td class="memItemLeft" align="right" valign="top"><a id="a89b79e9d3ed6ab7cb7b2d18c9187f323"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Transform</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:a89b79e9d3ed6ab7cb7b2d18c9187f323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1e63df9c774aba9b7e63514abb2e08"><td class="memItemLeft" align="right" valign="top"><a id="a1b1e63df9c774aba9b7e63514abb2e08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Abs</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a1b1e63df9c774aba9b7e63514abb2e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef8ba29c4eb0440cba4a0fdd14ce486"><td class="memItemLeft" align="right" valign="top"><a id="a7ef8ba29c4eb0440cba4a0fdd14ce486"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Exp</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a7ef8ba29c4eb0440cba4a0fdd14ce486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c08b3ef1c6322992a35c98c576dd29d"><td class="memItemLeft" align="right" valign="top"><a id="a6c08b3ef1c6322992a35c98c576dd29d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Log</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a6c08b3ef1c6322992a35c98c576dd29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3081f3c4d1cc49b832e4f0a53e20e17b"><td class="memItemLeft" align="right" valign="top"><a id="a3081f3c4d1cc49b832e4f0a53e20e17b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReLU</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a3081f3c4d1cc49b832e4f0a53e20e17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aadab5abc790c89a4bafb3f6be92fbd"><td class="memItemLeft" align="right" valign="top"><a id="a5aadab5abc790c89a4bafb3f6be92fbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Sigmoid</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a5aadab5abc790c89a4bafb3f6be92fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17258c50680efb29527b7f06f48105ea"><td class="memItemLeft" align="right" valign="top"><a id="a17258c50680efb29527b7f06f48105ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Sign</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a17258c50680efb29527b7f06f48105ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d840b6f19824aed55d503747968dfe"><td class="memItemLeft" align="right" valign="top"><a id="a25d840b6f19824aed55d503747968dfe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Sqrt</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a25d840b6f19824aed55d503747968dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbda8d805d940bb621b5a96b9f99cfe2"><td class="memItemLeft" align="right" valign="top"><a id="adbda8d805d940bb621b5a96b9f99cfe2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Square</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:adbda8d805d940bb621b5a96b9f99cfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f0f5d707d84384ad3345075a5f367a"><td class="memItemLeft" align="right" valign="top"><a id="a25f0f5d707d84384ad3345075a5f367a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Tanh</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a25f0f5d707d84384ad3345075a5f367a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cacbffb82d62692298aa0425496e1f"><td class="memItemLeft" align="right" valign="top"><a id="af2cacbffb82d62692298aa0425496e1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Transform</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:af2cacbffb82d62692298aa0425496e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbde4047c1a99ef9be6f200dc044806"><td class="memTemplParams" colspan="2"><a id="aadbde4047c1a99ef9be6f200dc044806"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:aadbde4047c1a99ef9be6f200dc044806"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#aadbde4047c1a99ef9be6f200dc044806">Pow</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x)</td></tr>
<tr class="memdesc:aadbde4047c1a99ef9be6f200dc044806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise opeartion, out[i]=in[i]^x. <br /></td></tr>
<tr class="separator:aadbde4047c1a99ef9be6f200dc044806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cccb472242b85e4a5c45c98fa2ddbf2"><td class="memTemplParams" colspan="2"><a id="a2cccb472242b85e4a5c45c98fa2ddbf2"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a2cccb472242b85e4a5c45c98fa2ddbf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a2cccb472242b85e4a5c45c98fa2ddbf2">Pow</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a2cccb472242b85e4a5c45c98fa2ddbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise opeartion, out[i]=in[i]^x. <br /></td></tr>
<tr class="separator:a2cccb472242b85e4a5c45c98fa2ddbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499267ad8d4a9364da5288492fbd470a"><td class="memItemLeft" align="right" valign="top"><a id="a499267ad8d4a9364da5288492fbd470a"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a499267ad8d4a9364da5288492fbd470a">Pow</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;base, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;exp)</td></tr>
<tr class="memdesc:a499267ad8d4a9364da5288492fbd470a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise opeartion, out[i]=baes[i]^exp[i]. <br /></td></tr>
<tr class="separator:a499267ad8d4a9364da5288492fbd470a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e3a2a861a54eabeb90278ced19f164"><td class="memItemLeft" align="right" valign="top"><a id="a41e3a2a861a54eabeb90278ced19f164"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a41e3a2a861a54eabeb90278ced19f164">Pow</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;base, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;exp, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a41e3a2a861a54eabeb90278ced19f164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise opeartion, out[i]=baes[i]^exp[i]. <br /></td></tr>
<tr class="separator:a41e3a2a861a54eabeb90278ced19f164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32aced0fc027b31ba656a9370343737e"><td class="memTemplParams" colspan="2"><a id="a32aced0fc027b31ba656a9370343737e"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a32aced0fc027b31ba656a9370343737e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a32aced0fc027b31ba656a9370343737e">operator&lt;</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x)</td></tr>
<tr class="memdesc:a32aced0fc027b31ba656a9370343737e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise operation, out[i]= (in[i] &lt; x) ? 1.f : 0.f. <br /></td></tr>
<tr class="separator:a32aced0fc027b31ba656a9370343737e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105e1ed5e64edfa8e9643163fe8b16d2"><td class="memTemplParams" colspan="2"><a id="a105e1ed5e64edfa8e9643163fe8b16d2"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a105e1ed5e64edfa8e9643163fe8b16d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LT</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a105e1ed5e64edfa8e9643163fe8b16d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2153501169050a1c5a697ae5986d488c"><td class="memItemLeft" align="right" valign="top"><a id="a2153501169050a1c5a697ae5986d488c"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a2153501169050a1c5a697ae5986d488c">operator&lt;</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in1, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in2)</td></tr>
<tr class="memdesc:a2153501169050a1c5a697ae5986d488c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise operation, out[i]= (in1[i] &lt; in2[i]) ? 1.f : 0.f. <br /></td></tr>
<tr class="separator:a2153501169050a1c5a697ae5986d488c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afc1256157c15f331788a8473bebb0b"><td class="memItemLeft" align="right" valign="top"><a id="a2afc1256157c15f331788a8473bebb0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LT</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in1, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in2, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a2afc1256157c15f331788a8473bebb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cf24d8a5a2f1cd550090bf3345007a"><td class="memTemplParams" colspan="2"><a id="ab9cf24d8a5a2f1cd550090bf3345007a"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:ab9cf24d8a5a2f1cd550090bf3345007a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ab9cf24d8a5a2f1cd550090bf3345007a">operator&lt;=</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x)</td></tr>
<tr class="memdesc:ab9cf24d8a5a2f1cd550090bf3345007a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise operation, out[i]= (in[i] &lt;= x) ? 1.f : 0.f. <br /></td></tr>
<tr class="separator:ab9cf24d8a5a2f1cd550090bf3345007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c3220fcf6d67c53ea0e46b6ea64d60"><td class="memTemplParams" colspan="2"><a id="a10c3220fcf6d67c53ea0e46b6ea64d60"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a10c3220fcf6d67c53ea0e46b6ea64d60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LE</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a10c3220fcf6d67c53ea0e46b6ea64d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a7fbb748b87ff0a079608ad71e5dbd"><td class="memItemLeft" align="right" valign="top"><a id="a59a7fbb748b87ff0a079608ad71e5dbd"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a59a7fbb748b87ff0a079608ad71e5dbd">operator&lt;=</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in1, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in2)</td></tr>
<tr class="memdesc:a59a7fbb748b87ff0a079608ad71e5dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise operation, out[i]= (in1[i] &lt;= in2[i]) ? 1.f : 0.f. <br /></td></tr>
<tr class="separator:a59a7fbb748b87ff0a079608ad71e5dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc1e8017e49e46a69aa03d1fd3121e5"><td class="memItemLeft" align="right" valign="top"><a id="a7cc1e8017e49e46a69aa03d1fd3121e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LE</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in1, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in2, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a7cc1e8017e49e46a69aa03d1fd3121e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a83210a25db36901c9b2ae2af76ba9"><td class="memTemplParams" colspan="2"><a id="ae1a83210a25db36901c9b2ae2af76ba9"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:ae1a83210a25db36901c9b2ae2af76ba9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ae1a83210a25db36901c9b2ae2af76ba9">operator&gt;</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x)</td></tr>
<tr class="memdesc:ae1a83210a25db36901c9b2ae2af76ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise operation, out[i]= (in[i] &gt; x) ? 1.f : 0.f. <br /></td></tr>
<tr class="separator:ae1a83210a25db36901c9b2ae2af76ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff95e86f03fae91494dc75a6bf14c308"><td class="memTemplParams" colspan="2"><a id="aff95e86f03fae91494dc75a6bf14c308"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:aff95e86f03fae91494dc75a6bf14c308"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GT</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:aff95e86f03fae91494dc75a6bf14c308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7236514693dbf6119d6a0d0a3f50418c"><td class="memItemLeft" align="right" valign="top"><a id="a7236514693dbf6119d6a0d0a3f50418c"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a7236514693dbf6119d6a0d0a3f50418c">operator&gt;</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in1, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in2)</td></tr>
<tr class="memdesc:a7236514693dbf6119d6a0d0a3f50418c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise operation, out[i]= (in1[i] &gt; in2[i]) ? 1.f : 0.f. <br /></td></tr>
<tr class="separator:a7236514693dbf6119d6a0d0a3f50418c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025cb5af00e8374a615b4e3f477b0310"><td class="memItemLeft" align="right" valign="top"><a id="a025cb5af00e8374a615b4e3f477b0310"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GT</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in1, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in2, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a025cb5af00e8374a615b4e3f477b0310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c577269e20e1bc2773a0ceb5ab86ec"><td class="memTemplParams" colspan="2"><a id="a86c577269e20e1bc2773a0ceb5ab86ec"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a86c577269e20e1bc2773a0ceb5ab86ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a86c577269e20e1bc2773a0ceb5ab86ec">operator&gt;=</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x)</td></tr>
<tr class="memdesc:a86c577269e20e1bc2773a0ceb5ab86ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise operation, out[i]= (in[i] &gt;= x) ? 1.f : 0.f. <br /></td></tr>
<tr class="separator:a86c577269e20e1bc2773a0ceb5ab86ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4088543969a1e0aee9fb6e0f3e8f8ae7"><td class="memTemplParams" colspan="2"><a id="a4088543969a1e0aee9fb6e0f3e8f8ae7"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a4088543969a1e0aee9fb6e0f3e8f8ae7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GE</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a4088543969a1e0aee9fb6e0f3e8f8ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59beccbc446f80fddd107ac85d7d4e12"><td class="memItemLeft" align="right" valign="top"><a id="a59beccbc446f80fddd107ac85d7d4e12"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a59beccbc446f80fddd107ac85d7d4e12">operator&gt;=</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in1, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in2)</td></tr>
<tr class="memdesc:a59beccbc446f80fddd107ac85d7d4e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise operation, out[i]= (in1[i] &gt;= in2[i]) ? 1.f : 0.f. <br /></td></tr>
<tr class="separator:a59beccbc446f80fddd107ac85d7d4e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95418f1021df70bfef567aed4917a3b8"><td class="memItemLeft" align="right" valign="top"><a id="a95418f1021df70bfef567aed4917a3b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GE</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in1, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in2, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a95418f1021df70bfef567aed4917a3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e4204f0aa0eced47dc6c75d00eb1b5"><td class="memItemLeft" align="right" valign="top"><a id="a71e4204f0aa0eced47dc6c75d00eb1b5"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;lhs, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;rhs)</td></tr>
<tr class="separator:a71e4204f0aa0eced47dc6c75d00eb1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b04aea2fb4671bce33d8fbc63c75fe"><td class="memItemLeft" align="right" valign="top"><a id="a45b04aea2fb4671bce33d8fbc63c75fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Add</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;lhs, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;rhs, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a45b04aea2fb4671bce33d8fbc63c75fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bc7a269bb7c5920a641de741739d32"><td class="memItemLeft" align="right" valign="top"><a id="ac0bc7a269bb7c5920a641de741739d32"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;lhs, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;rhs)</td></tr>
<tr class="separator:ac0bc7a269bb7c5920a641de741739d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23bb3b4dd62ba24baab6d4afcdc153"><td class="memItemLeft" align="right" valign="top"><a id="a7c23bb3b4dd62ba24baab6d4afcdc153"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Sub</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;lhs, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;rhs, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a7c23bb3b4dd62ba24baab6d4afcdc153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df13fa3e65398e283d76ae87ac58ce1"><td class="memItemLeft" align="right" valign="top"><a id="a3df13fa3e65398e283d76ae87ac58ce1"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;lhs, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;rhs)</td></tr>
<tr class="separator:a3df13fa3e65398e283d76ae87ac58ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516906bd33c8bc3299bef65c7e768e2c"><td class="memItemLeft" align="right" valign="top"><a id="a516906bd33c8bc3299bef65c7e768e2c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EltwiseMult</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;lhs, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;rhs, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a516906bd33c8bc3299bef65c7e768e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1108004a45b0b8a3841bb3f9426148f8"><td class="memItemLeft" align="right" valign="top"><a id="a1108004a45b0b8a3841bb3f9426148f8"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;lhs, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;rhs)</td></tr>
<tr class="separator:a1108004a45b0b8a3841bb3f9426148f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3438f59a2fb742eeab208ee7263ac8db"><td class="memItemLeft" align="right" valign="top"><a id="a3438f59a2fb742eeab208ee7263ac8db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Div</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;lhs, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;rhs, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a3438f59a2fb742eeab208ee7263ac8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ae14f31019173d688e5d847ff18ada"><td class="memTemplParams" colspan="2"><a id="af5ae14f31019173d688e5d847ff18ada"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:af5ae14f31019173d688e5d847ff18ada"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x)</td></tr>
<tr class="separator:af5ae14f31019173d688e5d847ff18ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dbf3ff27ced4e0b0ab0ddc2f669771"><td class="memTemplParams" colspan="2"><a id="a89dbf3ff27ced4e0b0ab0ddc2f669771"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a89dbf3ff27ced4e0b0ab0ddc2f669771"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Add</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a89dbf3ff27ced4e0b0ab0ddc2f669771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd19b0fe2e77ece62a9c9a2106a2e51"><td class="memTemplParams" colspan="2"><a id="a4bd19b0fe2e77ece62a9c9a2106a2e51"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a4bd19b0fe2e77ece62a9c9a2106a2e51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x)</td></tr>
<tr class="separator:a4bd19b0fe2e77ece62a9c9a2106a2e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de0f1419fb9000da5298586ad0ecc8d"><td class="memTemplParams" colspan="2"><a id="a9de0f1419fb9000da5298586ad0ecc8d"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a9de0f1419fb9000da5298586ad0ecc8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Sub</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a9de0f1419fb9000da5298586ad0ecc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20eac0aba571ec7b4f8bfb6d6177614"><td class="memTemplParams" colspan="2"><a id="ac20eac0aba571ec7b4f8bfb6d6177614"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:ac20eac0aba571ec7b4f8bfb6d6177614"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x)</td></tr>
<tr class="separator:ac20eac0aba571ec7b4f8bfb6d6177614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7902ae68aa6f4ab958cab012651a7a11"><td class="memTemplParams" colspan="2"><a id="a7902ae68aa6f4ab958cab012651a7a11"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a7902ae68aa6f4ab958cab012651a7a11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EltwiseMult</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="separator:a7902ae68aa6f4ab958cab012651a7a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03737f1fc5f53366fdbb06b77a41bc9"><td class="memTemplParams" colspan="2"><a id="ab03737f1fc5f53366fdbb06b77a41bc9"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:ab03737f1fc5f53366fdbb06b77a41bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ab03737f1fc5f53366fdbb06b77a41bc9">operator/</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x)</td></tr>
<tr class="memdesc:ab03737f1fc5f53366fdbb06b77a41bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each element e of <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> 'in', compute e / x. <br /></td></tr>
<tr class="separator:ab03737f1fc5f53366fdbb06b77a41bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf4db6f9813e466197dca9bc5edc94e"><td class="memTemplParams" colspan="2"><a id="afaf4db6f9813e466197dca9bc5edc94e"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:afaf4db6f9813e466197dca9bc5edc94e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#afaf4db6f9813e466197dca9bc5edc94e">Div</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const SType x, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:afaf4db6f9813e466197dca9bc5edc94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each element e of <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> 'in', compute e / x into out. <br /></td></tr>
<tr class="separator:afaf4db6f9813e466197dca9bc5edc94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7ddb0be8a3dfd4534ac8fefa2f1c34"><td class="memTemplParams" colspan="2"><a id="a9f7ddb0be8a3dfd4534ac8fefa2f1c34"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a9f7ddb0be8a3dfd4534ac8fefa2f1c34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a9f7ddb0be8a3dfd4534ac8fefa2f1c34">Div</a> (const SType x, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="memdesc:a9f7ddb0be8a3dfd4534ac8fefa2f1c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each element e of <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> 'in', compute x/e. <br /></td></tr>
<tr class="separator:a9f7ddb0be8a3dfd4534ac8fefa2f1c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9b78b28c5b7bf411c3742387f76e20"><td class="memTemplParams" colspan="2"><a id="a1e9b78b28c5b7bf411c3742387f76e20"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a1e9b78b28c5b7bf411c3742387f76e20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a1e9b78b28c5b7bf411c3742387f76e20">Div</a> (const SType x, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a1e9b78b28c5b7bf411c3742387f76e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each element e of <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> 'in', compute x/e into 'out'. <br /></td></tr>
<tr class="separator:a1e9b78b28c5b7bf411c3742387f76e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2ed63dd7acfece63b1a09e75b225da"><td class="memTemplParams" colspan="2"><a id="a7a2ed63dd7acfece63b1a09e75b225da"></a>
template&lt;typename SType  = float&gt; </td></tr>
<tr class="memitem:a7a2ed63dd7acfece63b1a09e75b225da"><td class="memTemplItemLeft" align="right" valign="top">SType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Sum</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:a7a2ed63dd7acfece63b1a09e75b225da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8ade3c623ecb13de53f14da2728df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a9a8ade3c623ecb13de53f14da2728df8">Average</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const int axis)</td></tr>
<tr class="memdesc:a9a8ade3c623ecb13de53f14da2728df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average elements in the <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a>, currently only support vector and matrix.  <a href="#a9a8ade3c623ecb13de53f14da2728df8">More...</a><br /></td></tr>
<tr class="separator:a9a8ade3c623ecb13de53f14da2728df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554727b758d0cbd7f21cd94e65f18f93"><td class="memItemLeft" align="right" valign="top"><a id="a554727b758d0cbd7f21cd94e65f18f93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a554727b758d0cbd7f21cd94e65f18f93">AddColumn</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;v, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *M)</td></tr>
<tr class="memdesc:a554727b758d0cbd7f21cd94e65f18f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add column 'v' with each column of matrix M. <br /></td></tr>
<tr class="separator:a554727b758d0cbd7f21cd94e65f18f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99174091f942384e0aa5cdbb4d493cc"><td class="memTemplParams" colspan="2"><a id="ab99174091f942384e0aa5cdbb4d493cc"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:ab99174091f942384e0aa5cdbb4d493cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ab99174091f942384e0aa5cdbb4d493cc">AddColumn</a> (const SType alpha, const SType beta, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;v, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:ab99174091f942384e0aa5cdbb4d493cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each column 'c' of matrix out, do c=alpha*v + beta*c. <br /></td></tr>
<tr class="separator:ab99174091f942384e0aa5cdbb4d493cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbe7f264403cb0e91f86ca216ec2710"><td class="memItemLeft" align="right" valign="top"><a id="a0cbe7f264403cb0e91f86ca216ec2710"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a0cbe7f264403cb0e91f86ca216ec2710">AddRow</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;v, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a0cbe7f264403cb0e91f86ca216ec2710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add row 'v' with each row of matrix M; write results into 'out'. <br /></td></tr>
<tr class="separator:a0cbe7f264403cb0e91f86ca216ec2710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7c2d0ce4c0b704d2719d93f0251e76"><td class="memTemplParams" colspan="2"><a id="a1b7c2d0ce4c0b704d2719d93f0251e76"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a1b7c2d0ce4c0b704d2719d93f0251e76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a1b7c2d0ce4c0b704d2719d93f0251e76">AddRow</a> (const SType alpha, const SType beta, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;v, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *M)</td></tr>
<tr class="memdesc:a1b7c2d0ce4c0b704d2719d93f0251e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each row 'r' of matrix out, do r=alpha*v + beta*r. <br /></td></tr>
<tr class="separator:a1b7c2d0ce4c0b704d2719d93f0251e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2906481968cf623515b5caed9c232463"><td class="memItemLeft" align="right" valign="top"><a id="a2906481968cf623515b5caed9c232463"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a2906481968cf623515b5caed9c232463">DivColumn</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;v, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *M)</td></tr>
<tr class="memdesc:a2906481968cf623515b5caed9c232463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide column 'v' by each column of matrix M; write results into 'out'. <br /></td></tr>
<tr class="separator:a2906481968cf623515b5caed9c232463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2685cc922445171b1c1a270f54d19d5"><td class="memItemLeft" align="right" valign="top"><a id="aa2685cc922445171b1c1a270f54d19d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#aa2685cc922445171b1c1a270f54d19d5">DivRow</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;v, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *M)</td></tr>
<tr class="memdesc:aa2685cc922445171b1c1a270f54d19d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide row 'v' by each row of matrix M; write results into 'out'. <br /></td></tr>
<tr class="separator:aa2685cc922445171b1c1a270f54d19d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee1fee4dfd8a49997341c2c12be2557"><td class="memItemLeft" align="right" valign="top"><a id="aaee1fee4dfd8a49997341c2c12be2557"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#aaee1fee4dfd8a49997341c2c12be2557">MultColumn</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;v, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *M)</td></tr>
<tr class="memdesc:aaee1fee4dfd8a49997341c2c12be2557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply column 'v' and each column of matrix M; write results into 'out'. <br /></td></tr>
<tr class="separator:aaee1fee4dfd8a49997341c2c12be2557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42f7253e6fd95e28757a0fcc30e50ea"><td class="memItemLeft" align="right" valign="top"><a id="af42f7253e6fd95e28757a0fcc30e50ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#af42f7253e6fd95e28757a0fcc30e50ea">MultRow</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;v, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *M)</td></tr>
<tr class="memdesc:af42f7253e6fd95e28757a0fcc30e50ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply row 'v' with each row of matrix M; write results into 'out'. <br /></td></tr>
<tr class="separator:af42f7253e6fd95e28757a0fcc30e50ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25f7f15d8b9719a610a24c1ad81facd"><td class="memItemLeft" align="right" valign="top"><a id="ab25f7f15d8b9719a610a24c1ad81facd"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ab25f7f15d8b9719a610a24c1ad81facd">SoftMax</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="memdesc:ab25f7f15d8b9719a610a24c1ad81facd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do softmax for each row. 'in' could be a 1-d or 2-d <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a>. <br /></td></tr>
<tr class="separator:ab25f7f15d8b9719a610a24c1ad81facd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ace19b3e7419d4d6534b4976b9a626"><td class="memItemLeft" align="right" valign="top"><a id="a68ace19b3e7419d4d6534b4976b9a626"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RowMax</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in)</td></tr>
<tr class="separator:a68ace19b3e7419d4d6534b4976b9a626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6b2833ed00ace43384c67a246b6d28"><td class="memItemLeft" align="right" valign="top"><a id="a6e6b2833ed00ace43384c67a246b6d28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a6e6b2833ed00ace43384c67a246b6d28">SoftMax</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a6e6b2833ed00ace43384c67a246b6d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do softmax for each row. 'in' could be a 1-d or 2-d <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a>. <br /></td></tr>
<tr class="separator:a6e6b2833ed00ace43384c67a246b6d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629d839716eb77397c632d1af6dce5f2"><td class="memItemLeft" align="right" valign="top"><a id="a629d839716eb77397c632d1af6dce5f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a629d839716eb77397c632d1af6dce5f2">SubColumn</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;v, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *M)</td></tr>
<tr class="memdesc:a629d839716eb77397c632d1af6dce5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub column 'v' by each column of matrix M. <br /></td></tr>
<tr class="separator:a629d839716eb77397c632d1af6dce5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37f3f825414426f54bf7bedd6ffa8aa"><td class="memItemLeft" align="right" valign="top"><a id="ac37f3f825414426f54bf7bedd6ffa8aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ac37f3f825414426f54bf7bedd6ffa8aa">SubRow</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;v, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *M)</td></tr>
<tr class="memdesc:ac37f3f825414426f54bf7bedd6ffa8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub row 'v' by each row of matrix M; write results into 'out'. <br /></td></tr>
<tr class="separator:ac37f3f825414426f54bf7bedd6ffa8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976fe0564db9515f38650b5628d92c86"><td class="memItemLeft" align="right" valign="top"><a id="a976fe0564db9515f38650b5628d92c86"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a976fe0564db9515f38650b5628d92c86">SumColumns</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;M, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a976fe0564db9515f38650b5628d92c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum all columns of matrix M into a single column as 'out'. <br /></td></tr>
<tr class="separator:a976fe0564db9515f38650b5628d92c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37daa1263efbf66896d6948f779f7d07"><td class="memItemLeft" align="right" valign="top"><a id="a37daa1263efbf66896d6948f779f7d07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a37daa1263efbf66896d6948f779f7d07">SumRows</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;M, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a37daa1263efbf66896d6948f779f7d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum all rows of matrix M into a single row as 'out'. <br /></td></tr>
<tr class="separator:a37daa1263efbf66896d6948f779f7d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046c11f765cd1d656aca1d55f3dec40b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a046c11f765cd1d656aca1d55f3dec40b">Sum</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const int axis)</td></tr>
<tr class="memdesc:a046c11f765cd1d656aca1d55f3dec40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum elements in the <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a>, currently only support vector and matrix.  <a href="#a046c11f765cd1d656aca1d55f3dec40b">More...</a><br /></td></tr>
<tr class="separator:a046c11f765cd1d656aca1d55f3dec40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19821f4d8f8ad56bab702b3a71e82d39"><td class="memTemplParams" colspan="2"><a id="a19821f4d8f8ad56bab702b3a71e82d39"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a19821f4d8f8ad56bab702b3a71e82d39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a19821f4d8f8ad56bab702b3a71e82d39">Bernoulli</a> (const SType p, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a19821f4d8f8ad56bab702b3a71e82d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each element x set x = 1 if random() &lt; p; otherwise x = 1. <br /></td></tr>
<tr class="separator:a19821f4d8f8ad56bab702b3a71e82d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3120367553786e8e658c89e9b71d5ec7"><td class="memTemplParams" colspan="2"><a id="a3120367553786e8e658c89e9b71d5ec7"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a3120367553786e8e658c89e9b71d5ec7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a3120367553786e8e658c89e9b71d5ec7">Gaussian</a> (const SType mean, const SType std, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a3120367553786e8e658c89e9b71d5ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> 't' following Gaussian distribution. <br /></td></tr>
<tr class="separator:a3120367553786e8e658c89e9b71d5ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6340f2195aa5759e2f2266848a4c57e0"><td class="memTemplParams" colspan="2"><a id="a6340f2195aa5759e2f2266848a4c57e0"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a6340f2195aa5759e2f2266848a4c57e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a6340f2195aa5759e2f2266848a4c57e0">Uniform</a> (const SType low, const SType high, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a6340f2195aa5759e2f2266848a4c57e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> 't' following uniform distribution. <br /></td></tr>
<tr class="separator:a6340f2195aa5759e2f2266848a4c57e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7389cb7b91f0265c19f0968b02c8245b"><td class="memTemplParams" colspan="2"><a id="a7389cb7b91f0265c19f0968b02c8245b"></a>
template&lt;typename SType &gt; </td></tr>
<tr class="memitem:a7389cb7b91f0265c19f0968b02c8245b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a7389cb7b91f0265c19f0968b02c8245b">Axpy</a> (SType alpha, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *out)</td></tr>
<tr class="memdesc:a7389cb7b91f0265c19f0968b02c8245b"><td class="mdescLeft">&#160;</td><td class="mdescRight">out = alpha*in + out <br /></td></tr>
<tr class="separator:a7389cb7b91f0265c19f0968b02c8245b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d703a9ddcb00877bb046a3576a91c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#aa8d703a9ddcb00877bb046a3576a91c2">Mult</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;A, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;B)</td></tr>
<tr class="memdesc:aa8d703a9ddcb00877bb046a3576a91c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do matrix vector multipication or matrix matrix multiplication depdending on the <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> shape.  <a href="#aa8d703a9ddcb00877bb046a3576a91c2">More...</a><br /></td></tr>
<tr class="separator:aa8d703a9ddcb00877bb046a3576a91c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a3e2237f3fdd6840c4ae746c1a8335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ac3a3e2237f3fdd6840c4ae746c1a8335">Mult</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;A, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;B, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *C)</td></tr>
<tr class="memdesc:ac3a3e2237f3fdd6840c4ae746c1a8335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do matrix vector multipication or matrix matrix multiplication depdending on the <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> shape.  <a href="#ac3a3e2237f3fdd6840c4ae746c1a8335">More...</a><br /></td></tr>
<tr class="separator:ac3a3e2237f3fdd6840c4ae746c1a8335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcd07f26ae83ac0c62327e12d28c98a"><td class="memTemplParams" colspan="2">template&lt;typename SType &gt; </td></tr>
<tr class="memitem:affcd07f26ae83ac0c62327e12d28c98a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinga.html#affcd07f26ae83ac0c62327e12d28c98a">Mult</a> (const SType alpha, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;A, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;B, const SType beta, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *C)</td></tr>
<tr class="memdesc:affcd07f26ae83ac0c62327e12d28c98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do matrix vector multipication or matrix matrix multiplication depdending on the <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> shape.  <a href="#affcd07f26ae83ac0c62327e12d28c98a">More...</a><br /></td></tr>
<tr class="separator:affcd07f26ae83ac0c62327e12d28c98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eefff7a89f48b481f069aafef927f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a64eefff7a89f48b481f069aafef927f8">ComputeCrossEntropy</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;p, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;t, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *loss)</td></tr>
<tr class="memdesc:a64eefff7a89f48b481f069aafef927f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross entropy loss given the prediction probability 'p' and the target (ground truth) labels 't'.  <a href="#a64eefff7a89f48b481f069aafef927f8">More...</a><br /></td></tr>
<tr class="separator:a64eefff7a89f48b481f069aafef927f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9a080006025616d7278b23a8ab4cd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#aab9a080006025616d7278b23a8ab4cd4">SoftmaxCrossEntropyBwd</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;t, <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *p)</td></tr>
<tr class="memdesc:aab9a080006025616d7278b23a8ab4cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dx, given prediction probability 'p' (p=softmax(x)) and the target (ground truth) labels 't'.  <a href="#aab9a080006025616d7278b23a8ab4cd4">More...</a><br /></td></tr>
<tr class="separator:aab9a080006025616d7278b23a8ab4cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53079f0b86e65883b6335f436512a58"><td class="memItemLeft" align="right" valign="top"><a id="ad53079f0b86e65883b6335f436512a58"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ad53079f0b86e65883b6335f436512a58">CrossEntropyFwd</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;p, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;t)</td></tr>
<tr class="memdesc:ad53079f0b86e65883b6335f436512a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called by pysinga autograd operations; swig ignores the const qualifier <a href="http://www.swig.org/Doc3.0/SWIGPlus.html#SWIGPlus_const">http://www.swig.org/Doc3.0/SWIGPlus.html#SWIGPlus_const</a>. <br /></td></tr>
<tr class="separator:ad53079f0b86e65883b6335f436512a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fd27ce36833b727e7e66e0eef7ce3a"><td class="memItemLeft" align="right" valign="top"><a id="a67fd27ce36833b727e7e66e0eef7ce3a"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SoftmaxCrossEntropyBwd</b> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;p, const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;t)</td></tr>
<tr class="separator:a67fd27ce36833b727e7e66e0eef7ce3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9582dbe30dae3caa0f6c72546d4b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a2d9582dbe30dae3caa0f6c72546d4b22">CopyRows</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const size_t start, const size_t end)</td></tr>
<tr class="memdesc:a2d9582dbe30dae3caa0f6c72546d4b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a tensor consisting of rows ([start, end)) from 'in'.  <a href="#a2d9582dbe30dae3caa0f6c72546d4b22">More...</a><br /></td></tr>
<tr class="separator:a2d9582dbe30dae3caa0f6c72546d4b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e159ad4bd62b5794956485a38fee212"><td class="memItemLeft" align="right" valign="top"><a id="a8e159ad4bd62b5794956485a38fee212"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a8e159ad4bd62b5794956485a38fee212">SliceRows</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const size_t start, const size_t end)</td></tr>
<tr class="memdesc:a8e159ad4bd62b5794956485a38fee212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of CopyRows. <br /></td></tr>
<tr class="separator:a8e159ad4bd62b5794956485a38fee212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db0996d454f23b8ed4ea502f2a464c1"><td class="memItemLeft" align="right" valign="top"><a id="a9db0996d454f23b8ed4ea502f2a464c1"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a9db0996d454f23b8ed4ea502f2a464c1">SliceOn</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const size_t start, const size_t end, int axis)</td></tr>
<tr class="memdesc:a9db0996d454f23b8ed4ea502f2a464c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice the input tensor along the give axis to generate a new tensor. <br /></td></tr>
<tr class="separator:a9db0996d454f23b8ed4ea502f2a464c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dc577c7352b7b3621cd26b060f681c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a52dc577c7352b7b3621cd26b060f681c">CopyColumns</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const size_t start, const size_t end)</td></tr>
<tr class="memdesc:a52dc577c7352b7b3621cd26b060f681c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a tensor consisting of columns ([start, end)) from 'in'.  <a href="#a52dc577c7352b7b3621cd26b060f681c">More...</a><br /></td></tr>
<tr class="separator:a52dc577c7352b7b3621cd26b060f681c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4b7304c7c43a3260fdbba3b658af36"><td class="memItemLeft" align="right" valign="top"><a id="a6e4b7304c7c43a3260fdbba3b658af36"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a6e4b7304c7c43a3260fdbba3b658af36">SliceColumns</a> (const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;in, const size_t start, const size_t end)</td></tr>
<tr class="memdesc:a6e4b7304c7c43a3260fdbba3b658af36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of CopyColumns. <br /></td></tr>
<tr class="separator:a6e4b7304c7c43a3260fdbba3b658af36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4544a98aa7368f85cc3212351d8286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a2f4544a98aa7368f85cc3212351d8286">ConcatenateRows</a> (const vector&lt; <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &gt; &amp;in)</td></tr>
<tr class="memdesc:a2f4544a98aa7368f85cc3212351d8286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a tensor which is vertically stacked from tensors in 'in'.  <a href="#a2f4544a98aa7368f85cc3212351d8286">More...</a><br /></td></tr>
<tr class="separator:a2f4544a98aa7368f85cc3212351d8286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170f75a92f322a9c8f1aba9944af9e47"><td class="memItemLeft" align="right" valign="top"><a id="a170f75a92f322a9c8f1aba9944af9e47"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a170f75a92f322a9c8f1aba9944af9e47">ConcatOn</a> (const std::vector&lt; <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &gt; &amp;in, int axis)</td></tr>
<tr class="memdesc:a170f75a92f322a9c8f1aba9944af9e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a tensor concatenated of the input tensors along the give axis. <br /></td></tr>
<tr class="separator:a170f75a92f322a9c8f1aba9944af9e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ab601583a3077c44452d3d2587f14f"><td class="memItemLeft" align="right" valign="top"><a id="ae4ab601583a3077c44452d3d2587f14f"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ae4ab601583a3077c44452d3d2587f14f">ConcatRows</a> (const vector&lt; <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &gt; &amp;in)</td></tr>
<tr class="memdesc:ae4ab601583a3077c44452d3d2587f14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias name for function ConcatenateRows. <br /></td></tr>
<tr class="separator:ae4ab601583a3077c44452d3d2587f14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db709d730eb5e04877535cd697c1863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a1db709d730eb5e04877535cd697c1863">ConcatenateColumns</a> (const vector&lt; <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &gt; &amp;in)</td></tr>
<tr class="memdesc:a1db709d730eb5e04877535cd697c1863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a tensor which is horizontally stacked from tensors in 'in'.  <a href="#a1db709d730eb5e04877535cd697c1863">More...</a><br /></td></tr>
<tr class="separator:a1db709d730eb5e04877535cd697c1863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91dc0734073421d7aa9eff485cc4953"><td class="memItemLeft" align="right" valign="top"><a id="ae91dc0734073421d7aa9eff485cc4953"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ae91dc0734073421d7aa9eff485cc4953">ConcatColumns</a> (const vector&lt; <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &gt; &amp;in)</td></tr>
<tr class="memdesc:ae91dc0734073421d7aa9eff485cc4953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias name for function ConcatenateColumns. <br /></td></tr>
<tr class="separator:ae91dc0734073421d7aa9eff485cc4953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49c3576f4fb05f6d83326e621d137ca"><td class="memItemLeft" align="right" valign="top"><a id="ad49c3576f4fb05f6d83326e621d137ca"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>crop</b> (<a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;input, const size_t crop_height, const size_t crop_width, const size_t crop_h_offset, const size_t crop_w_offset, const string &amp;image_dim_order)</td></tr>
<tr class="separator:ad49c3576f4fb05f6d83326e621d137ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eca343b878f60bad6eb844086c791b"><td class="memItemLeft" align="right" valign="top"><a id="a68eca343b878f60bad6eb844086c791b"></a>
<a class="el" href="classsinga_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mirror</b> (<a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;input, const bool horizontal_mirror, const bool vertical_mirror, const string &amp;image_dim_order)</td></tr>
<tr class="separator:a68eca343b878f60bad6eb844086c791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1032086971b3f60913e6e7c53694ac"><td class="memItemLeft" align="right" valign="top"><a id="add1032086971b3f60913e6e7c53694ac"></a>
std::shared_ptr&lt; <a class="el" href="classsinga_1_1Initializer.html">Initializer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#add1032086971b3f60913e6e7c53694ac">CreateInitializer</a> (const <a class="el" href="namespacesinga.html#ac7e303fc44cfdbf2611a6e69affa42e9">InitializerConf</a> &amp;conf)</td></tr>
<tr class="memdesc:add1032086971b3f60913e6e7c53694ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO(wangwei) create the initializers from factory like that for <a class="el" href="classsinga_1_1Layer.html" title="The base layer class. ">Layer</a>. <br /></td></tr>
<tr class="separator:add1032086971b3f60913e6e7c53694ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1330c3a9617bb3d0cf5a3161685787"><td class="memItemLeft" align="right" valign="top"><a id="abf1330c3a9617bb3d0cf5a3161685787"></a>
std::shared_ptr&lt; <a class="el" href="classsinga_1_1Layer.html">Layer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateLayer</b> (const std::string type)</td></tr>
<tr class="separator:abf1330c3a9617bb3d0cf5a3161685787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124c5155edf2d5ebf58e8c38e73a1c5c"><td class="memItemLeft" align="right" valign="top"><a id="a124c5155edf2d5ebf58e8c38e73a1c5c"></a>
const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetRegisteredLayers</b> ()</td></tr>
<tr class="separator:a124c5155edf2d5ebf58e8c38e73a1c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff1fc505fdeb7acf2d66e0aef3f02f6"><td class="memItemLeft" align="right" valign="top"><a id="a6ff1fc505fdeb7acf2d66e0aef3f02f6"></a>
std::shared_ptr&lt; <a class="el" href="classsinga_1_1Constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateConstraint</b> (std::string type)</td></tr>
<tr class="separator:a6ff1fc505fdeb7acf2d66e0aef3f02f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4dfa2e232a9ab238a1c6a1bf85dc99"><td class="memItemLeft" align="right" valign="top"><a id="a1f4dfa2e232a9ab238a1c6a1bf85dc99"></a>
std::shared_ptr&lt; <a class="el" href="classsinga_1_1Regularizer.html">Regularizer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateRegularizer</b> (std::string type)</td></tr>
<tr class="separator:a1f4dfa2e232a9ab238a1c6a1bf85dc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603f1cdaaf723fbc5803892c5b00014b"><td class="memItemLeft" align="right" valign="top"><a id="a603f1cdaaf723fbc5803892c5b00014b"></a>
std::shared_ptr&lt; <a class="el" href="classsinga_1_1Optimizer.html">Optimizer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateOptimizer</b> (const string &amp;type)</td></tr>
<tr class="separator:a603f1cdaaf723fbc5803892c5b00014b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d23cb2a4ace11df4c98f6912facc5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a89d23cb2a4ace11df4c98f6912facc5e">InitChannel</a> (const char *argv)</td></tr>
<tr class="memdesc:a89d23cb2a4ace11df4c98f6912facc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial function for global usage of channel.  <a href="#a89d23cb2a4ace11df4c98f6912facc5e">More...</a><br /></td></tr>
<tr class="separator:a89d23cb2a4ace11df4c98f6912facc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9d8f53816244f6006141817e3b86db"><td class="memItemLeft" align="right" valign="top"><a id="adc9d8f53816244f6006141817e3b86db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#adc9d8f53816244f6006141817e3b86db">SetChannelDirectory</a> (const char *path)</td></tr>
<tr class="memdesc:adc9d8f53816244f6006141817e3b86db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the directory name for persisting channel content. <br /></td></tr>
<tr class="separator:adc9d8f53816244f6006141817e3b86db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f76ab8b6f81bc2400f9b8df855f40aa"><td class="memItemLeft" align="right" valign="top"><a id="a8f76ab8b6f81bc2400f9b8df855f40aa"></a>
<a class="el" href="classsinga_1_1Channel.html">Channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a8f76ab8b6f81bc2400f9b8df855f40aa">GetChannel</a> (const std::string &amp;channel_name)</td></tr>
<tr class="memdesc:a8f76ab8b6f81bc2400f9b8df855f40aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the channel instance. <br /></td></tr>
<tr class="separator:a8f76ab8b6f81bc2400f9b8df855f40aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c53496f790ff43b264f4cd84b723ea"><td class="memItemLeft" align="right" valign="top"><a id="aa1c53496f790ff43b264f4cd84b723ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#aa1c53496f790ff43b264f4cd84b723ea">InitLogging</a> (const char *argv)</td></tr>
<tr class="memdesc:aa1c53496f790ff43b264f4cd84b723ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global functions for both glog and built-in log. <br /></td></tr>
<tr class="separator:aa1c53496f790ff43b264f4cd84b723ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e79d66673cb3bd4e824d3a14979244"><td class="memItemLeft" align="right" valign="top"><a id="ad5e79d66673cb3bd4e824d3a14979244"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ad5e79d66673cb3bd4e824d3a14979244">LogToStderr</a> ()</td></tr>
<tr class="memdesc:ad5e79d66673cb3bd4e824d3a14979244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make it so that all log messages go only to stderr. <br /></td></tr>
<tr class="separator:ad5e79d66673cb3bd4e824d3a14979244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45997ae6f3babb10023156d4c0993fc"><td class="memItemLeft" align="right" valign="top"><a id="af45997ae6f3babb10023156d4c0993fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#af45997ae6f3babb10023156d4c0993fc">SetStderrLogging</a> (int severity)</td></tr>
<tr class="memdesc:af45997ae6f3babb10023156d4c0993fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make it so that all log messages of at least a particular severity are logged to stderr (in addtion to logging to the usual log files) <br /></td></tr>
<tr class="separator:af45997ae6f3babb10023156d4c0993fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f5f64072659d14ef6251faaead345a"><td class="memItemLeft" align="right" valign="top"><a id="a23f5f64072659d14ef6251faaead345a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#a23f5f64072659d14ef6251faaead345a">SetLogDestination</a> (int severity, const char *path)</td></tr>
<tr class="memdesc:a23f5f64072659d14ef6251faaead345a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file name for logging (and disable logging to stderr) <br /></td></tr>
<tr class="separator:a23f5f64072659d14ef6251faaead345a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5d0b19124f11c193a14f000bc9770f"><td class="memItemLeft" align="right" valign="top"><a id="a9b5d0b19124f11c193a14f000bc9770f"></a>
mkldnn::memory::data_type&#160;</td><td class="memItemRight" valign="bottom"><b>GetMKLDNNDataType</b> (DataType dtype)</td></tr>
<tr class="separator:a9b5d0b19124f11c193a14f000bc9770f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee4c185b9eebbc3c9a9059fcaac3224"><td class="memItemLeft" align="right" valign="top"><a id="a2ee4c185b9eebbc3c9a9059fcaac3224"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>icasecmp</b> (const string &amp;l, const string &amp;r)</td></tr>
<tr class="separator:a2ee4c185b9eebbc3c9a9059fcaac3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9127c62b2b71529f135c0f5610fda3b6"><td class="memItemLeft" align="right" valign="top"><a id="a9127c62b2b71529f135c0f5610fda3b6"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>ToLowerCase</b> (const string &amp;input)</td></tr>
<tr class="separator:a9127c62b2b71529f135c0f5610fda3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b40b06645dc6876f60558bba639c3d"><td class="memItemLeft" align="right" valign="top"><a id="a72b40b06645dc6876f60558bba639c3d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ArgPos</b> (int argc, char **arglist, const char *arg)</td></tr>
<tr class="separator:a72b40b06645dc6876f60558bba639c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaceeedfd7dc285cc2a1bd0094132af8"><td class="memTemplParams" colspan="2"><a id="afaceeedfd7dc285cc2a1bd0094132af8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afaceeedfd7dc285cc2a1bd0094132af8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VecToStr</b> (const std::vector&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:afaceeedfd7dc285cc2a1bd0094132af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af5fd1cb4e1a4b5ae9bba1377b034eb8d"><td class="memItemLeft" align="right" valign="top"><a id="af5fd1cb4e1a4b5ae9bba1377b034eb8d"></a>
std::shared_ptr&lt; <a class="el" href="classsinga_1_1Device.html">Device</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#af5fd1cb4e1a4b5ae9bba1377b034eb8d">defaultDevice</a></td></tr>
<tr class="memdesc:af5fd1cb4e1a4b5ae9bba1377b034eb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">a singleton CppDevice as the host for all devices. <br /></td></tr>
<tr class="separator:af5fd1cb4e1a4b5ae9bba1377b034eb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5251edd2ae9cde0ad5c22ba98756469"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinga.html#ac5251edd2ae9cde0ad5c22ba98756469">kDataWidth</a> []</td></tr>
<tr class="memdesc:ac5251edd2ae9cde0ad5c22ba98756469"><td class="mdescLeft">&#160;</td><td class="mdescRight">hardcode the width of types defined in DataType  <a href="#ac5251edd2ae9cde0ad5c22ba98756469">More...</a><br /></td></tr>
<tr class="separator:ac5251edd2ae9cde0ad5c22ba98756469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd91f6428f4041a2df70d526ae7df45d"><td class="memItemLeft" align="right" valign="top"><a id="acd91f6428f4041a2df70d526ae7df45d"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>INFO</b> = 0</td></tr>
<tr class="separator:acd91f6428f4041a2df70d526ae7df45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab993a19cf72d4b9d5c16f5562e559e6e"><td class="memItemLeft" align="right" valign="top"><a id="ab993a19cf72d4b9d5c16f5562e559e6e"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>WARNING</b> = 1</td></tr>
<tr class="separator:ab993a19cf72d4b9d5c16f5562e559e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486ae99aafbfe5114c8d71e4edefb2c2"><td class="memItemLeft" align="right" valign="top"><a id="a486ae99aafbfe5114c8d71e4edefb2c2"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>ERROR</b> = 2</td></tr>
<tr class="separator:a486ae99aafbfe5114c8d71e4edefb2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bec91266a685c3d0f8998298fb6d05"><td class="memItemLeft" align="right" valign="top"><a id="a07bec91266a685c3d0f8998298fb6d05"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>FATAL</b> = 3</td></tr>
<tr class="separator:a07bec91266a685c3d0f8998298fb6d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f56f9f5f81ff0da44d3a43c9c23373"><td class="memItemLeft" align="right" valign="top"><a id="a75f56f9f5f81ff0da44d3a43c9c23373"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_SEVERITIES</b> = 4</td></tr>
<tr class="separator:a75f56f9f5f81ff0da44d3a43c9c23373"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. </p>
<p>See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9a8ade3c623ecb13de53f14da2728df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8ade3c623ecb13de53f14da2728df8">&#9670;&nbsp;</a></span>Average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> singa::Average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average elements in the <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a>, currently only support vector and matrix. </p>
<p>if 'axis' is 0, average all rows into a single row if 'axis' is 1, average all columns into a single column TODO(wangwei) support arbitrary <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> like numpy.average </p>

</div>
</div>
<a id="a64eefff7a89f48b481f069aafef927f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64eefff7a89f48b481f069aafef927f8">&#9670;&nbsp;</a></span>ComputeCrossEntropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void singa::ComputeCrossEntropy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>loss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cross entropy loss given the prediction probability 'p' and the target (ground truth) labels 't'. </p>
<p>'p' could be either a 1-d vector for a single instance or a 2-d matrix for a batch of instances. t[i] could be the ground truth label index or a label weighted array of the i-th instance. For example, if there are 3 candidate labels for each instance, t[i] could be 2 or [0, 0, 1]. If one instance could have multiple labels, then t[i] could be [1, 0, 1]. The loss is computed into p. </p>

</div>
</div>
<a id="a1db709d730eb5e04877535cd697c1863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db709d730eb5e04877535cd697c1863">&#9670;&nbsp;</a></span>ConcatenateColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> singa::ConcatenateColumns </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a tensor which is horizontally stacked from tensors in 'in'. </p>
<p>Each tensor in 'in' is a 2D tensor. Values are copied, no memory sharing. </p>

</div>
</div>
<a id="a2f4544a98aa7368f85cc3212351d8286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4544a98aa7368f85cc3212351d8286">&#9670;&nbsp;</a></span>ConcatenateRows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> singa::ConcatenateRows </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a tensor which is vertically stacked from tensors in 'in'. </p>
<p>Each tensor in 'in' is a 2D tensor. Values are copied, no memory sharing. </p>

</div>
</div>
<a id="a52dc577c7352b7b3621cd26b060f681c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dc577c7352b7b3621cd26b060f681c">&#9670;&nbsp;</a></span>CopyColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> singa::CopyColumns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a tensor consisting of columns ([start, end)) from 'in'. </p>
<p>It copies the values from 'in'. 'in' is a 2D <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a>. </p>

</div>
</div>
<a id="a62c886196156af2804db614775d2d29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c886196156af2804db614775d2d29f">&#9670;&nbsp;</a></span>CopyDataToFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void singa::CopyDataToFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dst_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>src_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy 'num' elements of src to dst. </p>
<p>The first 'src_offset' ('dst_offset') elements will be skipped. </p>

</div>
</div>
<a id="a2d9582dbe30dae3caa0f6c72546d4b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9582dbe30dae3caa0f6c72546d4b22">&#9670;&nbsp;</a></span>CopyRows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> singa::CopyRows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a tensor consisting of rows ([start, end)) from 'in'. </p>
<p>It copies the values from 'in'. 'in' ia a 2D <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a>. </p>

</div>
</div>
<a id="a89d23cb2a4ace11df4c98f6912facc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d23cb2a4ace11df4c98f6912facc5e">&#9670;&nbsp;</a></span>InitChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void singa::InitChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>argv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial function for global usage of channel. </p>
<p>'argv' is for future use. </p>

</div>
</div>
<a id="aa8d703a9ddcb00877bb046a3576a91c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d703a9ddcb00877bb046a3576a91c2">&#9670;&nbsp;</a></span>Mult() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> singa::Mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do matrix vector multipication or matrix matrix multiplication depdending on the <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> shape. </p>
<p>result = A * B </p>

</div>
</div>
<a id="ac3a3e2237f3fdd6840c4ae746c1a8335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a3e2237f3fdd6840c4ae746c1a8335">&#9670;&nbsp;</a></span>Mult() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void singa::Mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do matrix vector multipication or matrix matrix multiplication depdending on the <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> shape. </p>
<p>C = A * B </p>

</div>
</div>
<a id="affcd07f26ae83ac0c62327e12d28c98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcd07f26ae83ac0c62327e12d28c98a">&#9670;&nbsp;</a></span>Mult() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void singa::Mult </td>
          <td>(</td>
          <td class="paramtype">const SType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SType&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do matrix vector multipication or matrix matrix multiplication depdending on the <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> shape. </p>
<p>out = alpha lhs * rhs + beta * out </p>

</div>
</div>
<a id="aab9a080006025616d7278b23a8ab4cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9a080006025616d7278b23a8ab4cd4">&#9670;&nbsp;</a></span>SoftmaxCrossEntropyBwd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void singa::SoftmaxCrossEntropyBwd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dx, given prediction probability 'p' (p=softmax(x)) and the target (ground truth) labels 't'. </p>
<p>'p' and 't' are either 1-d vector or 2-d matrix. 'grad' has the same shape as 'p'. dx is computed into p. </p>

</div>
</div>
<a id="a046c11f765cd1d656aca1d55f3dec40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046c11f765cd1d656aca1d55f3dec40b">&#9670;&nbsp;</a></span>Sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinga_1_1Tensor.html">Tensor</a> singa::Sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsinga_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum elements in the <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a>, currently only support vector and matrix. </p>
<p>if 'axis' is 0, sum all rows into a single row if 'axis' is 1, sum all columns into a single column TODO(wangwei) support arbitrary <a class="el" href="classsinga_1_1Tensor.html" title="A Tensor instance is a multi-dimensional array resident on a Device (default device is the host CPU)...">Tensor</a> like numpy.sum </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac5251edd2ae9cde0ad5c22ba98756469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5251edd2ae9cde0ad5c22ba98756469">&#9670;&nbsp;</a></span>kDataWidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t singa::kDataWidth[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="keyword">sizeof</span>(float),  <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) / 2,</div><div class="line">                             <span class="keyword">sizeof</span>(int),    <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>),</div><div class="line">                             <span class="keyword">sizeof</span>(double), <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)</div><div class="line">                            }</div></div><!-- fragment -->
<p>hardcode the width of types defined in DataType </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 22 2019 12:27:05 for Apache Singa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
